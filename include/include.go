// package include defines include specs, which represent a subset of the
// object graph in the database. They can be used to instruct the code
// generated by pggen to load child entities attached to a given entity
// by a 1-1, 1-* or *-* relationship in an efficient way that avoids N+1 queries.
//
// In order to make defining include specs more convenient, they have a simple
// textual syntax for describing them. The syntax for include specs is reminiscent
// of dot access syntax, except that multiple tables can be accessed at once. For
// example, if you had an `foos` table that had a 1-* relationship with a `bars`
// table, you could use the following to produce an `include.Spec` to efficiently
// load all the bars attached to a foo:
//
// ```go
// spec := include.Must(include.Parse("foos.bars"))
// ```
//
// Dot access syntax works well enough when a table has just a single
// relationship, but it doesn't handle relationships with multiple tables,
// so include spec syntax allows you to write a list of sub-specs separated
// by commas and enclosed in a set of curly braces.
//
// For example, if the `foos` table also had a `bazes` attached to it with a 1-*
// relationship and the `bars` table had a `quxes` table attached to
// it in the same way, you could use to following to create a spec
// for loading all the objects attached to a given foo, even transitively.
//
// ```go
// spec := include.Must(include.Parse("foos.{bars.quxes, bazes}"))
// ```
//
// In order to match the semantics of SQL, include specs allow quoted
// identifiers, so the spec `"space table".{"how odd", "right?"}` is
// a valid include spec. Just like in SQL, you can escape a `"` in a
// quoted identifier with `""`.
//
// If a parent table uses a name besides the name of a child table to refer to it,
// the include spec must include this information somehow. In order to do this,
// include specs have rename expressions, which consist of the name used by the
// parent the '->' operator and the name of the child table. For example if the
// `sales` table referred to the users table with the name `customer`, an include
// spec for pulling customer data would look like `sales.customer->users`.
//
// More formally, the grammar for include specs is:
//
// spec ::= id
//        | id '.' inner_spec
//        | id '.' '{' spec_list '}'
// inner_spec ::= id
//        | rename_or_id '.' inner_spec
//        | rename_or_id '.' '{' spec_list '}'
// rename_or_id ::= id '->' id
//                | id
// spec_list ::= inner_spec
//             | inner_spec ',' inner_spec
//
// Cyclic Include Specs:
//
// The object graph in a database schema might have cyclic references, which don't
// map the most obviously to the hierarchical representation used by include specs,
// especially in their textual form. Include specs can still be used to describe
// cycles though. Each cycle in an include spec has a root node, which is the one
// closest to the root node of the include spec. Cycles are expressed as the path
// from the root node back to itself.
//
// For example, if the table `foo` referenced the table `bar` which contained a
// reference back to `foo`, the include spec `foo.bar.foo` could be used to capture
// that cycle.
//
// Filling in Parent References:
//
// SQL references are bidirectional, and pggen preserves those semantics in generated
// code by emitting pointers back to parent records in the model structs that it generates.
// These can be filled in using include specs, just like ordinary references, and doing so
// will not hit the database again if the parent record had already been loaded into memory.
// You do still need to explicitly tell pggen to fill in these references for you, which you
// can do by adding a sub-spec pointing to the parent. For example if the `bar` table refers
// to the `foo` table with a foreign key, we would usually think of the `foo` table as the
// parent and the `bar` table as the child. We have already seen that the include spec
// `foo.bar` would fill in the references in the generated `Foo` struct with generated `Bar`
// structs, but that won't fill in the references back to the parent from the `Bar` children.
// To do that we would need to use an include spec of `foo.bar.foo`.
package include

import (
	"fmt"
	"regexp"
	"sort"
	"strings"
	"unicode"
)

// Spec is the parsed form of an include spec. Specs can be constructed directly, or
// parsed from a terse string format using the Parse routine.
type Spec struct {
	// The name of the table that this is a spec for filling in
	TableName string
	// All the child tables to fill in
	Includes map[string]*Spec
}

func (s *Spec) String() string {
	var out strings.Builder

	seen := map[*Spec]bool{}
	s.writeToBuilder(&out, seen, false, nil)

	return out.String()
}

// Must can be used to turn an error from `include.Parse` into a panic
func Must(spec *Spec, err error) *Spec {
	if err != nil {
		panic(err)
	}
	return spec
}

// Parse an Spec from the given source string or an error on failure
func Parse(src string) (spec *Spec, err error) {
	specRef, idx, err := parseSpec(src, 0, false)
	if err != nil {
		return
	}

	// make sure there is no dangling input at the end
	idx = skipWS(src, idx)
	if idx < len(src) {
		err = &parseError{
			pos: idx,
			msg: fmt.Sprintf(
				"unexpected extra token begining with '%s'",
				string(src[idx]),
			),
		}
		return
	}

	spec = specRef.subSpec
	return
}

//
// parse helpers
//

type parseError struct {
	pos int
	msg string
}

func (pe *parseError) Error() string {
	return fmt.Sprintf("at offset %d: %s", pe.pos, pe.msg)
}

func skipWS(src string, idx int) int {
	if idx >= len(src) {
		return idx
	}

	max := 0
	for i, r := range src[idx:] {
		if !unicode.IsSpace(r) {
			return idx + i
		}
		max = i
	}
	return idx + max + 1
}

func parseSpec(src string, idx int, inner bool) (spec specReference, nextIdx int, err error) {
	spec = specReference{subSpec: &Spec{}}

	idx = skipWS(src, idx)
	if idx >= len(src) {
		err = &parseError{
			pos: idx,
			msg: "expected an identifier to start a spec",
		}
		return
	}
	if inner {
		spec.parentName, spec.subSpec.TableName, idx, err = parseRenameOrID(src, idx)
		if err != nil {
			return
		}
	} else {
		spec.subSpec.TableName, idx, err = parseID(src, idx)
		if err != nil {

			return
		}
		spec.parentName = spec.subSpec.TableName
	}

	idx = skipWS(src, idx)
	if idx >= len(src) || src[idx] != '.' {
		// a bare identifier or rename expression is a valid include spec
		nextIdx = idx
		return
	}

	idx++
	idx = skipWS(src, idx)
	if idx >= len(src) {
		err = &parseError{
			pos: idx,
			msg: "expected spec or list of specs after '.'",
		}
		return
	}

	if src[idx] == '{' {
		// look for a list of sub specs
		var specList []specReference
		specList, idx, err = parseSpecList(src, idx)
		if err != nil {
			return
		}

		spec.subSpec.Includes = map[string]*Spec{}
		for _, specRef := range specList {
			spec.subSpec.Includes[specRef.parentName] = specRef.subSpec
		}
	} else {
		// look for a solitary sub-spec not bracketed by curlies
		var specRef specReference
		specRef, idx, err = parseSpec(src, idx, true)
		if err != nil {
			return
		}
		spec.subSpec.Includes = map[string]*Spec{specRef.parentName: specRef.subSpec}
	}

	nextIdx = idx
	return
}

type specReference struct {
	parentName string
	subSpec    *Spec
}

func parseSpecList(src string, idx int) (specs []specReference, nextIdx int, err error) {
	specs = []specReference{}

	if src[idx] != '{' {
		err = &parseError{
			pos: idx,
			msg: "expected '{' to begin spec list",
		}
		return
	}

	unexpectedEOI := func(i int) error {
		return &parseError{
			pos: i,
			msg: "unexpected end of input while parsing spec list",
		}
	}

	idx++
	idx = skipWS(src, idx)
	if idx >= len(src) {
		err = unexpectedEOI(idx)
		return
	}

	// not needed, but produces a nicer error message
	if src[idx] == '}' {
		err = &parseError{
			pos: idx,
			msg: "empty spec list",
		}
		return
	}

	for {
		var specRef specReference
		specRef, idx, err = parseSpec(src, idx, true)
		if err != nil {
			return
		}

		specs = append(specs, specRef)

		idx = skipWS(src, idx)
		if idx >= len(src) {
			err = unexpectedEOI(idx)
			return
		}

		if src[idx] == '}' {
			idx++
			break
		}

		if src[idx] != ',' {
			err = &parseError{
				pos: idx,
				msg: "expected ',' to separate sub specs",
			}
			return
		}
		idx++
		idx = skipWS(src, idx)
		if idx >= len(src) {
			err = unexpectedEOI(idx)
			return
		}

		// allow trailing comma
		if src[idx] == '}' {
			idx++
			break
		}
	}

	nextIdx = idx
	return
}

// parse id '->' id | id
//
// If this just parses a solitary id, then the returned `id` with be the
// same as `renameTo`.
func parseRenameOrID(src string, idx int) (
	id string,
	renameTo string,
	nextIdx int,
	err error,
) {
	unexpectedEOI := func(i int) error {
		return &parseError{
			pos: idx,
			msg: "unexpected end of input when parsing a rename expression",
		}
	}

	id, idx, err = parseID(src, idx)
	if err != nil {
		return
	}

	idx = skipWS(src, idx)
	if idx+1 >= len(src) || !(src[idx] == '-' && src[idx+1] == '>') {
		// just a bare id
		nextIdx = idx
		renameTo = id
		return
	}

	idx = skipWS(src, idx+2)
	if idx >= len(src) {
		err = unexpectedEOI(idx)
		return
	}

	renameTo, idx, err = parseID(src, idx)
	if err != nil {
		return
	}

	nextIdx = idx
	return
}

// parse: [a-zA-Z_][a-zA-Z0-9_$]* | "[^"]"
func parseID(src string, idx int) (id string, nextIdx int, err error) {
	// first, we'll see if we are dealing with a quoted identifier
	if src[idx] == '"' {
		var idBuilder strings.Builder
		for {
			idx++
			if idx >= len(src) {
				err = &parseError{
					pos: idx,
					msg: "unexpected end of input in quoted identifier",
				}
				return
			}

			if src[idx] == '"' {
				if idx+1 < len(src) && src[idx+1] == '"' {
					idx++
					idBuilder.WriteByte('"')
				} else {
					id = idBuilder.String()
					nextIdx = idx + 1
					return
				}
			} else {
				idBuilder.WriteByte(src[idx])
			}
		}
	}

	// if it wasn't a quoted identifier we will fall through to looking
	// for a normal identifier

	seenFirst := false
	max := -1
	for i, r := range src[idx:] {
		stop := true
		if unicode.IsLetter(r) || r == '_' {
			stop = false
		}
		if seenFirst && (unicode.IsNumber(r) || r == '$') {
			stop = false
		}

		if stop {
			if i == 0 {
				err = &parseError{
					pos: idx,
					msg: fmt.Sprintf(
						"'%s' cannot begin an identifier",
						string(r),
					),
				}
			}

			id = src[idx : idx+i]
			nextIdx = idx + i
			return
		}

		max = i
		seenFirst = true
	}

	if max == -1 {
		return "", idx, &parseError{
			pos: idx,
			msg: "unexpected end of input when parsing an identifier",
		}
	} else {
		id = src[idx : idx+max+1]
		nextIdx = idx + max + 1
		return
	}
}

//
// write helpers
//

var unquotedIdentRE = regexp.MustCompile("^[a-zA-Z_][a-zA-Z0-9_$]*$")

func (s *Spec) writeToBuilder(b *strings.Builder, seen map[*Spec]bool, stop bool, parentName *string) {
	if parentName != nil && s.TableName != *parentName {
		// The name of the field in the parent struct and the child table
		// name do not match, so we need to print a rename expression.
		writeIdent(b, *parentName)
		b.WriteString("->")
		writeIdent(b, s.TableName)
	} else {
		// the field in the parent is the same as the table name, so we can just print
		// the table name.
		writeIdent(b, s.TableName)
	}

	if stop {
		return
	}
	seen[s] = true

	if len(s.Includes) == 1 {
		b.WriteByte('.')
		for n, subSpec := range s.Includes {
			subSpec.writeToBuilder(b, seen, seen[subSpec], &n)
		}
	} else if len(s.Includes) > 1 {
		b.WriteByte('.')

		type childSpec struct {
			parentName string
			subSpec    *Spec
		}

		// sort the sub-specs to ensure stable output
		childSpecs := make([]childSpec, len(s.Includes))[:0]
		for n, subSpec := range s.Includes {
			childSpecs = append(childSpecs, childSpec{
				parentName: n,
				subSpec:    subSpec,
			})
		}
		sort.Slice(childSpecs, func(i, j int) bool {
			return childSpecs[i].parentName < childSpecs[j].parentName
		})

		b.WriteByte('{')
		for i, childSpec := range childSpecs {
			childSpec.subSpec.writeToBuilder(b, seen, seen[childSpec.subSpec], &childSpec.parentName)
			if i < len(childSpecs)-1 {
				b.WriteByte(',')
			}
		}
		b.WriteByte('}')
	}
}

func writeIdent(b *strings.Builder, ident string) {
	if unquotedIdentRE.Match([]byte(ident)) {
		b.WriteString(ident)
	} else {
		quotedQuotes := strings.ReplaceAll(ident, `"`, `""`)
		b.WriteByte('"')
		b.WriteString(quotedQuotes)
		b.WriteByte('"')
	}
}
